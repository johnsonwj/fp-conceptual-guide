\documentclass{book}

% disable chktex warning about space before punctuation - it keeps complaining about the ':' in type declarations
% chktex-file 26
% chktex-file 18
% chktex-file 21
% chktex-file 36

\usepackage{textcomp}
\usepackage{listings}
\usepackage{blindtext}
\usepackage{xcolor}
\usepackage{mdframed}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[T1]{fontenc}

\definecolor{solar yellow}{HTML}{B58900}
\definecolor{solar orange}{HTML}{CB4B16}
\definecolor{solar red}{HTML}{DC322F}
\definecolor{solar magenta}{HTML}{D33682}
\definecolor{solar violet}{HTML}{6C71C4}
\definecolor{solar blue}{HTML}{268BD2}
\definecolor{solar cyan}{HTML}{2AA198}
\definecolor{solar green}{HTML}{859900}

\def\ifnotorange#1{%
\extractcolorspec{.}\currentcolor%
\extractcolorspec{solar orange}\stringcolor%
\ifx\currentcolor\stringcolor\else
    \color{#1}%
\fi
}

\lstset{
    showspaces=false,
    showstringspaces=false,
    basicstyle=\ttfamily\footnotesize,
    upquote=true,
    keywordstyle=\ifnotorange{solar blue},
    keywordstyle=[2]\ifnotorange{solar cyan},
    keywordstyle=[3]\ifnotorange{black},
    stringstyle=\color{solar orange},
    commentstyle=\color{solar violet}\itshape,
    texcl=true%
}

\lstdefinelanguage{pseudoml}{
    keywords={type, typeclass, instance, data, where, let, in, if, then, else, as},
    literate=
        {=}{{{\color{solar blue}=}}}{1}
        {|}{{{\color{solar blue}|}}}{1}
        {:}{{{\color{solar blue}:}}}{1}
        {=>}{{{\color{solar blue}\( \Rightarrow \)}}}{2}
        {->}{{{\color{solar blue}\( \rightarrow \)}}}{2}
        {==}{{{\color{black}==}}}{2}
        {/=}{{{\color{black}/=}}}{2}
        {<=}{{{\color{black}<=}}}{2}
        {>=}{{{\color{black}>=}}}{2}
        {::}{{{\color{solar magenta}::}}}{2},
    morestring=[b]",
    comment=[l]{--}
}

\def\beginlstdelim#1#2#3%
{%
    \def\endlstdelim{#2\egroup}%
    \ttfamily#1\bgroup\color{#3}\aftergroup\endlstdelim%
}

\lstdefinelanguage{js}{
    keywords={function, return, null, if, else, const, let},
    morekeywords=[2]{true, false},
    comment=[l]{//},
    morecomment=[s]{/*}{*/},
    moredelim=**[is][\color{solar yellow}\beginlstdelim{\$\{}{\}}{black}]{\$\{}{\}},
    morestring=[b]',
    morestring=**[b]{`},
    morestring=[b]"%
}

\newcommand{\mlil}[1]{\lstinline[language=pseudoml,columns=fixed]|#1|}\usepackage{caption}

\usepackage{newfloat}
\DeclareFloatingEnvironment[fileext=lol, name=Listing]{listing}

\usepackage{subcaption}
\DeclareCaptionSubType{listing}

\title{Functional Programming: A Conceptual Guide}
\author{Will Johnson}

\begin{document}

\maketitle
\tableofcontents

\chapter{Introduction}

\section{Goals \& Non-Goals}

The primary goal of this document is to provide a conceptual overview and motiviation for functional programming concepts in a more or less language-agnostic way.

Writing a conceptual guide, rather than aiming to teach a particular language, is somewhat quirky. A cynical but not completely inaccurate reader might observe that this choice (a) absolves us from having to attend to messy practical matters (build systems, disagreeable syntax\ldots), and (b) is a marketing decision because no one will pick up ``Yet Another Haskell Book: This Time It'll Make Sense, We Promise!'' However, we believe this choice is in the reader's interest too; to someone who is completely new to functional programming from even a conceptual standpoint, gaining intuition about how programs are organized and composed is difficult to do simultaneously with learning the practical parts like performance concerns and library management.

Ultimately this is still going to be about programming, so there will be ``code'' snippets. However, it is important to emphasize again that it is \textbf{not} a goal to teach any one programming language. Some examples will be written in languages such as Java or ECMAScript for comparison purposes, since they should be recognizable to most readers. That being said, Appendix~\ref{lang} provides a brief glance over some of the ways in which particular languages deviate from the names or styles introduced below.

For functional-style snippets, we will be using a syntax inspired by ML-family languages like Haskell because those languages were designed from the ground up to make programming in a functional style as efficient as possible. It is called ``PseudoML'' because it is sufficient to illustrate concepts, but it lacks many of the features that would make it suitable for parsing by a compiler; it is intended only for human readers. Section~\ref{sec:pseudoml} goes over that syntax, but first we should introduce functional programming in general.

\section{Functional Programming: What And Why}

Let's begin at the beginning. Programming languages are an abstraction over instructions that can be run by your CPU.\@ These instructions are fundamentally \emph{imperative}: we are telling the machine to read and write data between memory registers. Low-level languages like C are designed to be very thin, platform-independent wrappers over these instructions, with minimal control structures (for loops, structs) to simplify the work of reading and writing code.

C also allowed giving a name to a repeatable set of instructions that can be called from other parts of the program. These are usually called functions, but \emph{routine} might be a better word. Object-oriented languages like C++ or Java provide an additional level of abstraction over C, but keep the same imperative flavor: a \emph{class} describes a set of data and routines to operate on that data.

By contrast, a (purely) functional programming language departs from the imperative style entirely. They are \emph{declarative}: we describe \emph{what things are} rather than \emph{how to do them}, and the compiler takes care of translating what we write into imperative language. To illustrate the difference, Listing~\ref{lst:compare-imperative-declarative} shows some example code, written in imperative-style ECMAScript (\ref{lst:compare-id-imperative}) or in declarative pseudo-ML (\ref{lst:compare-id-declarative}). 

\begin{listing}
\begin{sublisting}{\linewidth}
\begin{lstlisting}[language=js]
function makeGreeting(name, todos) {
    const firstPart = `Hi, ${name}!`;
    let secondPart;
    if (todos && todos.length > 0) {
        let todoMsg = todos[0];
        for (let i = 1; i < todos.length; i++) {
            todoMsg += `; ${todos[i]}`;
        }
        secondPart = `Here are your tasks for the day: ${todoMsg}`;
    } else {
        secondPart = 'Congrats, you\'re all done for the day!';
    }
    return `${firstPart} ${secondPart}`
}
\end{lstlisting}
\caption{An example of imperative style in ECMAScript.}\label{lst:compare-id-imperative}
\end{sublisting}
\\[0.1\textheight]
\begin{sublisting}{\linewidth}
\begin{lstlisting}[language=pseudoml]
makeGreeting name todos =
    sayHello name ++ " " ++ todosMessage todos 

sayHello name = "Hi, " ++ name ++ "!"

todosMessage []        = "Congrats, you're all done for the day!"
todosMessage (t :: ts) = todosIntro ++ todosList where
    todosIntro = "Here are your tasks for the day: " 
    todosList  = t ++ listRemainingTodos ts

listRemainingTodos []        = "."
listRemainingTodos (t :: ts) = "; " ++ t ++ listRemainingTodos ts
\end{lstlisting}
\caption{An example of declarative style in PseudoML.}\label{lst:compare-id-declarative}
\end{sublisting}
\caption{Comparison of imperative and declarative styles.}\label{lst:compare-imperative-declarative}
\end{listing}

Both examples illustrate breaking the problem down into smaller pieces, but that's where the similarities end. A loop, for instance, is an imperative construct: ``repeatedly execute this block of instructions''. In functional programming, iterating over a list is generally accomplished by doing something with the head of the list and then recursing through the remainder (as in \mlil{listRemainingTodos}). Pattern matching on function arguments takes the place of if blocks to direct execution. These and other quirks of functional programming are all due to the fundamental difference between imperative and declarative styles.

That takes care of the ``what''. Why do people like functional programming? What does it gain over other paradigms? As with all things, it comes down to a combination of personal preference and math.

\subsection{Personal Preference}

People who prefer functional programming tend to be the same set of people who like statically-typed languages with very smart compilers. This is where basically all of the room for different opinions resides; I'll start by going over some of the reasoning behind that preference (as well as some of the arguments against it). Later on, I'll go over how that has to do with functional programming.

First, some definitions. A \emph{type system} is a way of assigning a property called \emph{type} to a given \emph{value} in the programming language. Types are a human construct that tell us something about what a program means: after all, inside the silicon we're just shuffling bits around. But when we have a function called \mlil{stringLength} and let the computer plug any random bits into it, there's a good chance that whatever comes out won't even make sense as an integer, let alone a measure of length!

To prevent this kind of faux pas, we tell the compiler (or the compiler infers from usage, if it's a smarty pants) that this function should only be called with one argument, a string, and the return value should only be used like an integer. We are in effect getting some documentation for free: clients can read the type signature of a function and understand quite a lot about its behavior, especially if we can guarantee that there are no ``side effects'' (more on that later). But that's not all! Static type checking can be considered a form of testing: not only does the compiler guarantee that the function is used correctly, but it can also guarantee that the \emph{definition} of the function upholds the type signature we claimed it should!

Strong static typing isn't a universal solution, though. We are in effect front-loading the work of discovering funny edge cases to compile-time, rather than run-time. Dynamically-typed, interpreted languages like Python and ECMAScript derive a lot of their appeal from the fact that they make it easy to crack out a lot of code \emph{fast}, and as long as it's syntactically correct it will run. With adequate tests, you can be reasonably sure that the code is correct; for small projects or scripts, this is frequently much more efficient.

But what happens when your project gets popular and starts being used by other people? Even with excellent documentation (which, of course, is always available) there's nothing preventing someone from accidentally passing a string into a function that expects a number. Can you guarantee that your code will fail quickly in such an event, without putting the client's system into a corrupted state? \emph{Should} you be expected to verify that at runtime?

Statically-typechecked code \emph{drastically} reduces the surface area for runtime errors, filtering out the noise from programmer errors or typos, and pulling them all the way to the front of the development cycle. For situations where that is desirable, like critical enterprise software that needs firm guarantees of correctness, the cost of the additional developer time fighting with the compiler is well worth avoiding potentially costly runtime issues. Even in less critical software, the ability of IDEs to typecheck code as you write it reduces the feedback loop even further, with the strong guarantee of correctness a happy side benefit.

Long story short, it comes down to: would you rather write possibly correct code really quickly, or really correct code possibly quickly? For various reasons that we'll explore presently, functional programming is an excellent choice for anyone who picks the latter option.

\subsection{Math}

Functional programming languages are designed to be very close to the language that mathematicians use to prove things like ``does this algorithm terminate?'' This makes it possible to write an \emph{exceptionally} smart compiler. Some of the questions that mathematicians might ask are

\begin{itemize}
    \item Can it be guaranteed that this program doesn't have an infinite loop?
    \item Can it be guaranteed that this program will run without an error?
    \item Can it be guaranteed that this program won't set my grandma on fire?
\end{itemize}

The language that mathematicians and logicians use to describe and (attempt to) answer these questions is called the \emph{lambda calculus}, which is very much out of the scope of this paper. Atop that framework is a language of types, which lets us say things like ``Here is a function called \mlil{stringLength}; if you plug in a string, this will return an integer representing the number of characters in that string; no other inputs are allowed.'' At this point, a compiler can check things like

\begin{itemize}
    \item Reject any program that attempts to plug something other than a string into \mlil{stringLength}
    \item Reject any program that attempts to use the output of \mlil{stringLength} as anything other than an integer
    \item Reject the program if \mlil{stringLength} returns something other than an integer
    \item Reject the program if \mlil{stringLength} does not accept any valid string
\end{itemize}

\noindent and---importantly---it is possible to \emph{mathematically prove} that the compiler answers those questions correctly. It is the ultimate in test technology: rather than relying on a mere finite number of example cases as in traditional testing, we can rely on \textbf{Mathematical Truth}\( ^{\text{TM}} \)!

Now, all that being said, software engineers shouldn't be expected to have math degrees! None of that background is required to actually \emph{use} the FP toolkit, in the same way that we don't need to know the instruction set for the processors in our laptops. It is just a convenience that we can take for granted when we write our code and it compiles.

\section{Functional Programming: Why Not?}

The mathematical heritage of functional programming has given it a reputation for being difficult to understand, or just a research toy for mathematicians and academics. There is a reason why this image developed, but it is not really well-deserved.

Consider the languages most of us use today. From their earliest ancestors, they were developed by computer nerds, who just wanted to tinker around and play tetris and talk to others of their kind on message boards.

By contrast, as we saw above, many of the contributions that formed the foundation for functional programming languages came from mathematicians and logicians. This is actually a very useful thing for us, but it comes with a price: they were there first, so they got to pick the names. Mathematicians are perfectly happy floating around in wizard robes and unironically saying things like ``oh yes Veronica, monads are just monoids in the category of endofunctors!'' Engineers live much closer to the real world and do not have time for such frippery, and have satisfied themselves with more normal-sounding terms like ``class'', ``object'', ``singleton'', or ``factory''.

So, yes, there will be some unfamiliar and mystical-sounding terms ahead. But fear not: they are just names, and the things they represent have solid programmer-friendly meanings.

\chapter{Basic Concepts}

\section{PseudoML Syntax}\label{sec:pseudoml}

Type declarations and assignments look like this: 

\begin{lstlisting}[language=pseudoml]
myInt : Int
myInt = 5

myString : String
myString = "Hello, world!"

type String = [Char]

myCharList : String
myCharList = ['H', 'e', 'l', 'l', 'o']
\end{lstlisting}

The \mlil{type} keyword creates a \emph{type synonym}; this is just a different label, sometimes to save on keyboard work for a frequently-used but complex type name, or sometimes as a form of documentation (as in \mlil{type UserId = String}). Brand new types are declared with \mlil{data}:

\begin{lstlisting}[language=pseudoml]
data Optional a = Just a | None

justFive : Optional Int
justFive = Just 5

noInt : Optional Int
noInt = None
\end{lstlisting}

Functions are defined like so:

\begin{lstlisting}[language=pseudoml]
stringLength : String -> Int
stringLength ""     = 0
stringLength (_::s) = 1 + stringLength s
\end{lstlisting}

Note the \emph{pattern matching} on the left-hand side of the \mlil{=}. This should be read as ``\mlil{stringLength} called with an empty string returns 0; otherwise, we know it isn't empty, so discard the head of the list and add 1 to the length of the remainder.''

Function application (that is, ``calling'' a function) is achieved by simply listing the arguments after the function name, as in \mlil{f x y z} which calls a function \mlil{f} with three arguments. Arguments are always applied from left to right:

\begin{lstlisting}[language=pseudoml]
myValue = f x y z -- same as: (((f x) y ) z)
\end{lstlisting}

\noindent and in general, it has higher precedence than any other operator:

\begin{lstlisting}[language=pseudoml]
myOtherValue = f x + g y -- same as: (f x) + (g y)
\end{lstlisting}

\section{Composition \& Currying}

Suppose we have

\begin{lstlisting}[language=pseudoml]
stringLength : String -> Int
isOdd : Int -> Bool
\end{lstlisting}

We could write

\begin{lstlisting}[language=pseudoml]
stringHasOddLength : String -> Bool
stringHasOddLength s = isOdd (stringLength s)
\end{lstlisting}

\noindent but that gets tedious quickly if we are chaining several functions together. The idiomatic way to do this is to use \emph{function composition}:

\begin{lstlisting}[language=pseudoml]
stringHasOddLength = isOdd . stringLength
\end{lstlisting}

The \mlil{.} in that definition is itself a function:

\begin{lstlisting}[language=pseudoml]
(.) : (b -> c) -> (a -> b) -> a -> c
(f . g) x = f (g x)
\end{lstlisting}

\noindent It says ``take the output of the function on the right, and plug it into the function on the left''. Note that the new definition of \mlil{stringHasOddLength} does not actually bind a name for the argument! We \emph{can} do that, as in

\begin{lstlisting}[language=pseudoml]
stringHasOddLength x = (isOdd . stringLength) x
\end{lstlisting}

\noindent but there is no need. We're just saying ``\mlil{stringHasOddLength} is the result of composing these two functions.'' This is called, somewhat misleadingly, ``point-free style.''\footnote{Mathematicians again. ``Point'' means ``function argument''; ``point-free'' means ``defined without binding a name to the arguments''.} You can do it in ES too:

\begin{lstlisting}[language=js]
const compose = (g, f) => x => g(f(x));
const stringLength = s => s.length;
const isOdd = i => i % 2 === 1;
const stringHasOddLength = compose(isOdd, stringLength);
\end{lstlisting}

If you were to take a static type analysis tool to this code, it would hopefully resolve the type of \mlil{stringHasOddLength} as a function from strings to booleans, despite not having actually used an explicit function definition that binds an argument name.

Point-free style is related to the concept of ``currying'', which is named after a person named Haskell Curry, not the food. If a function takes two arguments, and you feed it only one, the result is a function that takes one argument:

\begin{lstlisting}[language=pseudoml]
stringLengths = map stringLength
\end{lstlisting}

The \mlil{map} function is the usual: it takes a function \mlil{(a -> b)} and a list \mlil{[a]}, and then returns the result of applying the given function to each element of the list. So if we stare at this definition, since \mlil{stringLength : String -> Int}, we can deduce that \mlil{stringLengths : [String] -> [Int]}.

\section{Recursion}\label{sec:recursion}

Recursion is much more important in functional programming than in imperative programming, because recursion is the primary way to implement loops (in addition to the various other uses that it has in common with non-functional code). We will have much more to say about recursion later on (see Part~\ref{part:recursion}), but for now we can go over some basic examples to get us started.

Here's how we might implement \mlil{map} over lists:

\begin{lstlisting}[language=pseudoml]
map : (a -> b) -> [a] -> [b]
map _ []      = []
map f (x::xs) = f x :: map f xs
\end{lstlisting}

The \mlil{::} constructor sticks an element on the head of a list. The first equation takes care of the base case (stop recursing once we hit the end of the list), and the second one says to apply the function to the head of the list, and then do the same thing on to the remainder.

Here's another example, which works rather like Python's \lstinline[language=python]!range()! with one argument:

\begin{lstlisting}[language=pseudoml]
range : Int -> [Int]
range x = if x < 0 then [] else (x - 1) :: range (x - 1)
\end{lstlisting}

\section{Purity}\label{sec:purity}

There are a couple of meanings of \emph{pure}, depending on context:

\subsection{Pure Functional Languages}

A \emph{pure functional language}, such as Haskell, is a language that only supports functional-style programming, with no way to represent other programming patterns like object-oriented code. These are usually contrasted with ``functional-first'' languages like F\# or, depending on who you are talking to, Scala; in these languages, functional and object-oriented styles can coexist.

PseudoML is a pure functional language, because it was invented\footnote{Well, perhaps it is more accurate to say ``shamelessly cobbled together from bits of existing languages''} to illustrate functional programming concepts, so attempting to support additional syntax would just be distracting.

\subsection{Pure Functions}

A \emph{pure function} is a function that does not have any ``side effects'', such as updating a global state, writing to (or reading from!) a file, and so on. You don't need a pure functional language to write a pure function:

\begin{lstlisting}[language=js]
const pureAdd = (x, y) => x + y;
\end{lstlisting}

Pure functions are important for a couple of reasons. From a practical standpoint, they are easy to test; without any global state that can be corrupted by another process, or flaky I/O operations, we know that a pure function called with the same arguments will always produce the same result. From the standpoint of implementing a language, we can get a form of memoization for free: results of pure functions can be cached since the compiler can guarantee that there's no way for the result to change from one call to the next.

Of course, it doesn't make sense for a language to only support pure functions; the \emph{whole point} of running a program is to get the side effects! Side-effectful operations belong to their own type, \mlil{IO a}. For instance, an \mlil{IO Int} represents an operation that does something unspecified and then returns an \mlil{Int}. They are, therefore, somewhat spooky; running an \mlil{IO} ``action'' is dangerous if you don't know where it's been, since even an innocuous-seeming \mlil{IO Int} could represent the action ``wipe the hard drive and then return the number of dirty pictures that this program emailed your grandma''.

To facilitate effective testing (and out of a desire to be tidy), functional programmers generally try to keep as much of their code pure as possible. Consider, for instance, parsing an image file and returning the number of red pixels present in the image. Side effects are only required when reading the file and then printing the result to the console; everything in between is pure operations on the contents of the file, which is just a series of bytes. Folks who are new to functional programming often find the restriction of side effects to \mlil{IO} grating, but that is just after a lifetime of being able to sprinkle side effects around anywhere. Once you get used to structuring your code appropriately, it becomes second nature, and eventually the cavalier attitude of other languages toward side effects starts to feel a bit rude!

\begin{lstlisting}[language=js]
function justAddIPromise(x, y) {
    window.open('http://downloadvirus.biz');
    sendDirtyEmails('grandma@oldfolks.net');
    console.log('ha ha you suck');
    return x + y;
}
\end{lstlisting}

\section{Strictness \& Laziness}

Strictness refers to whether or not a given expression in the source code is actually evaluated by the processor. One famous example of ``non-strict semantics'' is what we call short-circuiting in boolean operators:

\begin{lstlisting}[language=js]
const everythingIsFine = true || fireAllMissiles();
\end{lstlisting}

The expression on the left-hand side of the \lstinline[language=js]!||! is always evaluated, but the right-hand side may not be, if the processor knows by then what the overall expression will evaluate to. On the other hand, most other operations, such as function calls, follow ``strict semantics'':

\begin{lstlisting}[language=js]
function uhoh(stuff, things) {
    console.log(`here is some stuff: ${stuff}`);
}

uhoh('my stuff', fireAllMissiles());
\end{lstlisting}

Whenever you call a function, the arguments are always evaluated \emph{first}, and then they are passed to the body of the function---regardless of whether the function body even refers to every argument it's given.

A term that is frequently used alongside ``non-strict'' is ``lazy''. Laziness is a way to \emph{implement} non-strictness. In a lazy language, all expressions are implicitly replaced by zero-argument functions that \emph{return} the expression's value, called a ``thunk'':

\begin{lstlisting}[language=js]
const two = 2;
const twoThunk = () => 2;
\end{lstlisting}

This is done behind the scenes, or else the code would be unacceptably cluttered. Although it makes it somewhat hard to decide whether some code will execute before or after another, the only times where that usually matters (namely, executing side-effectful actions) are wrapped up in the \mlil{IO} monad (more on that later!) which has a sense of ``do this before that'' built-in to the structure.

PseudoML as used here will in general be non-strict, though in the few places where it matters we will point that out. Specific languages have different ways to achieve strictness/non-strictness when that is not the default behavior, so we will leave it up to the reader to determine how to implement that in the wild.

\section{Typeclasses}

A typeclass is a set of functions that can be overloaded to work with any type. Defining how those functions work on a particular type is called \emph{implementing} that typeclass. The most basic typeclasses are \mlil{Eq}, \mlil{Ord}, and \mlil{Show}, which we will go over here. In the next section, we'll start getting into some of the meatier examples.

Languages with this concept usually include several functions in the typeclass definition, many of which may be given a ``default'' definition in terms of some minimal set that must be implemented. This is entirely for practical purposes; in specific cases, there may be a more efficient way to implement one of the ``extra'' functions. Such considerations are an implementation detail outside our scope, so we will limit our typeclasses to the minimal set of functions, and define the other ones separately when they are needed.

\subsection{Eq}

A data type can be made an instance of \mlil{Eq} if its values can be compared as equal or not equal. It is defined like this:

\begin{lstlisting}[language=pseudoml]
typeclass Eq a
    (==) : a -> a -> Bool
\end{lstlisting}

This says ``\mlil{a} is an instance of \mlil{Eq} if there is an implementation for the \mlil{(==)} function.'' As an example, consider a data type representing the three primary colors:

\begin{lstlisting}[language=pseudoml]
data PrimaryColor = Red | Blue | Green

instance Eq PrimaryColor
    Red   == Red   = True
    Blue  == Blue  = True
    Green == Green = True
    _     == _     = False
\end{lstlisting}

\noindent For ``obvious'' cases like this, the compiler can frequently implement this sort of thing on its own, but that functionality is generally language-dependent.

Polymorphic functions are written like this:

\begin{lstlisting}[language=pseudoml]
elem : Eq a => a -> [a] -> Bool
elem _ []      = False
elem e (x::xs) = e == x || elem e xs
\end{lstlisting}

The \mlil{=>} notation says that \mlil{a} can be any type, as long as it has an \mlil{Eq} instance. This is a function of two arguments: something to look for in a list, and the list in which to look. The second line says ``nothing is an empty list.'' The third line says ``check the first element in the list; if it is equal to what you're looking for, return \mlil{True}; otherwise, keep looking in the rest of the list.''

Incidentally, how do we compare lists? Two lists are equal if they have the same elements in the same order. This means that we need a way to compare the elements to see if they're equal too. So we might write \mlil{Eq [a]} like:

\begin{lstlisting}[language=pseudoml]
instance Eq a => Eq [a]
    []      == []      = True
    (x::xs) == (y::ys) = x == y && xs == ys
    _       == _       = False
\end{lstlisting}

\noindent This says ``two empty lists are equal; two nonempty lists are equal if their heads and tails are equal; otherwise, they are never equal.'' Note that the \mlil{Eq a} constraint is what lets us use \mlil{x == y}.

\subsection{Ord}

\mlil{Ord} types support a notion of ``ordering''. The class is defined like so:

\begin{lstlisting}[language=pseudoml]
data Ordering = LT | EQ | GT

typeclass Eq a => Ord a
    compare : a -> a -> Ordering
\end{lstlisting}

Similarly to its use in type signatures, the \mlil{=>} at the top says that in order to be an \mlil{Ord}, the type must also implement \mlil{Eq}. The usual operators like \mlil{<} are then defined in terms of \mlil{compare}; for instance,

\begin{lstlisting}[language=pseudoml]
x <  y = compare x y == LT
x >= y = not (x < y)
max x y = if x >= y then x else y
\end{lstlisting}

One of the nifty examples using \mlil{Ord} is a recursive implementation of the QuickSort algorithm.

\begin{lstlisting}[language=pseudoml]
sort : (Ord a) => [a] => [a]
sort []      = []
sort (x::xs) = sort left ++ (x :: sort right) where
    left  = filter (<  x) xs
    right = filter (>= x) xs
\end{lstlisting}

This is a pretty popular canonical ``look at how much better FP is!'' example, but it emphasizes cuteness over performance. If you are tempted to compare it favorably against an in-place sort implemented in e.g.\ C, keep in mind that the in-place algorithm is going to be much more space-efficient, and almost certainly less obvious than this little toy algorithm.

\subsection{Show}

\mlil{Show} is for types that can be represented as a string:

\begin{lstlisting}[language=pseudoml]
typeclass Show a
    show : a -> String
\end{lstlisting}

Most languages also have the ability to generate instances of \mlil{Show} for you. This is also simplified from the definition you might see in the wild, which is designed to support efficiently building the output string for nested structures. Just for fun, here's an example instance for lists whose elements are themselves \mlil{Show}able.

\begin{lstlisting}[language=pseudoml]
instance Show a => Show [a]
    show []      = "[]"
    show (x::xs) = "[" ++ show x ++ showNextElems xs ++ "]"

showNextElems : Show a => [a] -> String
showNextElems []      = ""
showNextElems (x::xs) = ", " ++ show x ++ showNextElems xs
\end{lstlisting}

\chapter{Intermediate Typeclasses}

So far, the typeclasses we've seen have obvious analogues in non-functional languages too. This section will look at a few of the typeclasses that are particularly important to functional programming design.

\section{Functor}

The \mlil{Functor} typeclass is for data types that can be treated like containers whose elements can be ``mapped over.'' Specifically:

\begin{lstlisting}[language=pseudoml]
typeclass Functor f
    map : (a -> b) -> f a -> f b
\end{lstlisting}

You might also think about a functor as a way to apply a function \emph{through} a data structure. Lists are a common example; indeed, many object-oriented languages give a \mlil{map} method to their array or list class.

\begin{lstlisting}[language=pseudoml]
instance Functor []
    map _ []      = []
    map f (x::xs) = f x :: map f xs

-- this evaluates to [10, 4]
someInts = map stringLength ["functional", "peep"]
\end{lstlisting}

\mlil{Optional} is also a useful \mlil{Functor}:

\begin{lstlisting}[language=pseudoml]
instance Functor Optional
    map _ Nothing  = Nothing
    map f (Just x) = Just (f x)
\end{lstlisting}

\section{Foldable}

\mlil{Foldable} is the typeclass of data structures that can be traversed, accumulating some result at each point:

\begin{lstlisting}[language=pseudoml]
typeclass Foldable t
    foldl : (b -> a -> b) -> b -> t a -> b
\end{lstlisting}

The \texttt{l} at the end of \texttt{foldl} indicates that this is a \emph{left fold}\footnote{This is also called a \emph{left-associative} fold, when there are mathematicians around.}. The words ``left'' and ``right'' refer to the head and tail of a list, respectively; in general, left folds start at the ``front'' of a data structure (they are \emph{breadth-first}), and right folds start at the ``back'' (\emph{depth-first}). What this means is best illustrated by an example. Consider this definition of the \mlil{sum} function, which sums a list of integers:

\begin{lstlisting}[language=pseudoml]
instance Foldable []
    foldl _ acc []     = acc
    foldl f acc (x:xs) = foldl f (f acc x) xs

sum : [Int] -> Int
sum = foldl (+) 0
\end{lstlisting}

Now let's consider what happens when this function is evaluated.

\begin{verbatim}
sum [1, 2, 4, 8]
foldl (+) 0 [1, 2, 4, 8]
foldl (+) (0 + 1) [2, 4, 8]
foldl (+) ((0 + 1) + 2) [4, 8]
foldl (+) (((0 + 1) + 2) + 4) [8]
foldl (+) ((((0 + 1) + 2) + 4) + 8) []
((((0 + 1) + 2) + 4) + 8)
\end{verbatim}

As you can see, the first thing to be evaluated is \( 0 + 1 \), and we proceed down the list, evaluating the ``left-most'' operations first. This implies the existence of a \emph{right fold}:

\begin{lstlisting}[language=pseudoml,texcl]
-- see Appendix~\ref{endo} for a generic foldr in terms of foldl
foldrList : (a -> b -> b) -> b -> [a] -> b
foldrList _ b [] = b
foldrList f b (x :: xs) = f x (foldr f b xs)

sumr : [Int] -> Int
sumr = foldr (+) 0
\end{lstlisting}

When this is evaluated, we get

\begin{verbatim}
sumr [1, 2, 4, 8]
foldr (+) 0 [1, 2, 4, 8]
(1 + (foldr (+) 0 [2, 4, 8]))
(1 + (2 + (foldr (+) 0 [4, 8])))
(1 + (2 + (4 + (foldr (+) 0 [8]))))
(1 + (2 + (4 + (8 + (foldr (+) 0 [])))))
(1 + (2 + (4 + (8 + 0))))
\end{verbatim}

Unsurprisingly, now we're starting on the right! This ends up evaluating to the same result, but that is only the case for \emph{associative} operations. You may recall from math class that this has to do with how we group a series of operations; if we just write \( 0 + 1 + 2 + 4 + 8 \) there are five different \( + \)s that we could choose to evaluate first. Of course, with addition, it doesn't matter; any way we group the operations comes out to the same result. We call functions with this property associative. On the other hand, subtraction is definitely not associative:

\begin{align*}
((((0 - 1) - 2) - 4) - 8) &= -15 \\
(1 - (2 - (4 - (8 - 0)))) &= -5
\end{align*}

In this case, \mlil{foldl} and \mlil{foldr} give different results! This isn't actually that big of a deal though---if you know which side you're starting from, you can always define your folding function appropriately (and perhaps reverse your list) in order to get the result you want. It turns out, though, that sometimes it does matter which fold you choose!

The examples above with \texttt{(+)} are \emph{reductions}: they collapse the list as they traverse it. Both reductions happen in linear time (since they traverse the input list exactly once), but \mlil{foldl} happens in constant space, while \mlil{foldr} uses linear space! For very long lists, this can easily overflow the stack. The reason is that when folding from the left, we're keeping a ``running total'' of the folded value; each rescursive call need not generate its own stack frame, so the fold only needs as much memory as is required to store the result value. On the other hand, folding from the right means that we must traverse the entire list before we can start evaluating stuff, and each time we recurse further into the list, we have to hold on to the current value while we wait for the evaluation to work its way back up the stack!

However, not all folds are reductions, and interestingly, the situation is reversed for non-reductive folds. Consider the two functions below, which implement \mlil{map} over a list, one with a left fold and the other with a right fold. You should be able to convince yourself that they both produce the same result as we saw for the \mlil{Functor} instance above:

\begin{lstlisting}[language=pseudoml]
mapl : (a -> b) -> [a] -> [b]
mapl f = foldl mapAndAppend [] where
    mapAndAppend ys x = ys ++ [f x]

mapr : (a -> b) -> [a] -> [b]
mapr f = foldr mapAndPrepend [] where
    mapAndPrepend x ys = f x :: ys
\end{lstlisting}

Note that when we're folding from the left, we put each successive result at the \emph{end} of the new list. Likewise, when we're folding from the right, we start at the end of the list, so we append each result to the head of the new list. Evaluating these as we did before, we get

\begin{lstlisting}[language=pseudoml]
mapl stringLength ["Mrs", "Birdy", "says", "peep"]
-- (((([] ++ [3]) ++ [5]) ++ [4]) ++ [4])

mapr stringLength ["Mrs", "Birdy", "says", "peep"]
-- (3 :: (5 :: (4 :: (4 :: []))))
\end{lstlisting}

The problem here is that concatenation using \mlil{++} runs in time proportional to the length of the left-hand list, and each time we do a concatenation, the left-hand list gets bigger; suddenly our left fold is in \emph{quadratic time}! We would therefore rather choose a right fold for this job, because it allows us to use the constant-time list constructor \mlil{::} rather than linear-time concatenation.

Now, depending on your language's evaluation rules, how it implements lists, and particuarly how smart its optimizer is, your mileage may vary. The moral of this story is that you should choose your fold so that reductions are \emph{strict and tail-recursive}, and non-reductive folds build the output structure efficiently, using only constant-time operations (if possible).

\section{Monoid}

First, a warning: monoids are to monads as Java is to JavaScript, so apologies in advance for the similar words. Blame mathematicians again.

Here's the definition of \mlil{Monoid}:

\begin{lstlisting}[language=pseudoml]
typeclass Monoid a
    empty : a
    (<>) : a -> a -> a
\end{lstlisting}

This can be read a couple of different ways. Usually the one folks see first treats \mlil{<>} as an operator for glomming two instances of the monoid together, with \mlil{empty} as the ``neutral'' element; for example, with integers:

\begin{lstlisting}[language=pseudoml]
instance Monoid Int as Sum
    empty = 0
    (<>)  = (+)

sum : [Int] -> Int
sum xs = foldl (<> using Prod)
\end{lstlisting}

Notice that I have named the instance; this can sometimes be useful, because there may be multiple ways for a given data type to implement a typeclass. Such as:

\begin{lstlisting}[language=pseudoml]
instance Monoid Int as Product
    empty = 1
    (<>)  = (*)
\end{lstlisting}

Each of these specifies a particular way that integers can be stuck together. With these examples handy, we can write down the \emph{monoid laws}:

\begin{description}
    \item[Associativity] \mlil{(x <> y) <> z == x <> (y <> z)}
    \item[Identity] \mlil{x <> empty == empty <> x == x}
\end{description}

The requirement that \mlil{<>} be associative means that there aren't monoid instances for division or subtraction. (By the way, division has another problem too---\mlil{<>} should always be defined for all values, but division by zero isn't defined!)

The other way to interpret a monoid is as a way to choose between two values with \mlil{<>}, with \mlil{empty} providing a default choice.

\begin{lstlisting}[language=pseudoml]
instance Monoid (Maybe a) as First
    empty = Nothing
    
    Just x <> Just y = Just x
    x <> Nothing     = x
    Nothing <> x     = x

instance Monoid (Maybe a) as Last
    empty = Nothing
    
    Just x <> Just y = Just y
    x <> Nothing     = x
    Nothing <> x     = x
\end{lstlisting}

Here, the \mlil{First} instance always chooses the first non-\mlil{Nothing} value it was given; likewise, \mlil{Last} always chooses the last.

As a final example, \mlil{Bool} also admits two possible monoids:

\begin{lstlisting}[language=pseudoml]
instance Monoid Bool as All
    empty = True
    (<>)  = (&&)

instance Monoid (Maybe a) as Any
    empty = False
    (<>)  = (||)
\end{lstlisting}

\section{Applicative}

The extravagantly-named \emph{applicative functor} is, of course, simply a functor that is applicative!

That sounds deeply, almost offensively unhelpful, but interestingly it's one of the more meaningful names for important concepts (looking at you, `Monad'). To illustrate what it means, let's consider a puzzle. A program has asked the user for two integers, \mlil{x} and \mlil{y}, but since getting these integers involves communing with the outside world of side effects, they are both of type \mlil{IO Int}. Your goal is to add them together. How can we do this?

Unlike most data types, \mlil{IO} values cannot be ``unwrapped'', because that would defeat the purpose of keeping side effects contained. \mlil{IO} is a functor, so we can do things like

\begin{lstlisting}[language=pseudoml]
x : IO Int
x = askUserForInt

y : IO Int
y = askUserForInt

z : IO Int
z = map (*2) x -- double it!
\end{lstlisting}

\noindent but before you ask, \mlil{x + y} doesn't work because \mlil{IO Int} is not a number! It's more like a \emph{promise} of a number, and in fact thinking about \mlil{IO} like an ES \lstinline[language=js]|Promise| or a Java \lstinline[language=java]|CompletableFuture| is not a terrible approximation.

Okay fine, it's a trick question, and presumably you have already figured out that the answer has to do with whatever an applicative is. Plain functors simply don't provide enough power to support this sort of operation. Happily, \mlil{IO} is an \mlil{Applicative}, which gives us access to this gadget:

\begin{lstlisting}[language=pseudoml]
liftA2 : (Applicative f) => (a -> b -> c) -> (f a -> f b -> f c)
-- definition will come in a moment!

addTwoIOs : IO Int -> IO Int -> IO Int
addTwoIOs = liftA2 (+)

addXAndY = addTwoIOs x y -- ta da!
\end{lstlisting}

The function \mlil{liftA2} takes a pure function of two arguments, and turns it into a function over an Applicative. The term \emph{lift} is one that will occur a lot; it's usually given to a function that takes a ``plain'' function and transforms it into a ``special'' one---e.g.\ \emph{lifting} the humble \mlil{(+)} into the exciting world of \mlil{IO}. ``\texttt{liftA}'' denotes a lift into Applicatives, and ``\texttt{liftA2}'' indicates that it operates on functions of two arguments; once you get over that hurdle, it's easy enough to construct \mlil{liftA}\( n \) but usually that's excessive. In fact, you've already seen \mlil{liftA1}: it's just functor \mlil{map}!

\begin{lstlisting}[language=pseudoml]
liftA1 : (Applicative f) => (a -> b) -> (f a -> f b)
-- where have I seen this type signature before?
\end{lstlisting}

Hopefully that is enough to start shedding light on the name \emph{applicative functor}. Let's look at how it's actually defined.

\begin{lstlisting}[language=pseudoml]
typeclass (Functor f) => Applicative f
    pure  : a -> f a
    (<*>) : f (a -> b) -> f a -> f b
\end{lstlisting}

The \mlil{pure} function lifts a plain value into an applicative. The name is intended to suggest that we're getting ``just'' that value: no spooky side effects, no accidental emails to scandalize grandma, it's a pure value. For instance, if we didn't want to bother asking the user for numbers (they would probably screw it up anyway), we could just say

\begin{lstlisting}[language=pseudoml]
myX : IO Int
myX = pure 2

myY : IO Int
myY = pure 3
\end{lstlisting}

The other thing, \mlil{(<*>)}, is pronounced ``apply'', and it takes a lifted single-argument function and applies it to a lifted value. These two things together allow us to define \mlil{liftA2}:

\begin{lstlisting}[language=pseudoml]
liftA2 : (Applicative f) => (a -> b -> c) -> (f a -> f b -> f c)
liftA2 f x y = pure f <*> x <*> y
\end{lstlisting}

Which is to say, we lift \mlil{f} up into the applicative, (partially!) apply it to \mlil{x}, and then finally apply that to \mlil{y}. In fact, we could have started with \mlil{liftA2} instead:

\begin{lstlisting}[language=pseudoml]
(<*>) : (Applicative f) -> f (a -> b) -> f a -> f b
f <*> x = liftA2 id f x
\end{lstlisting}

\section{Traversable}

\blindtext%

\section{Monad}

\blindtext%

\chapter{Monads: A Field Guide}

\section{Optional}

\blindtext%

\section{List}

\blindtext%

\section{Either}

\blindtext%

\section{IO}

\blindtext%

\section{Reader}

\blindtext%

\section{Writer}

\blindtext%

\section{State}

\blindtext%

\chapter{Recursion Schemes}\label{part:recursion}

\blindtext%

\chapter{Advanced Typeclasses}

\section{Alternative}

\blindtext%

\section{MonadPlus}

\blindtext%

\section{Arrow}

\blindtext%

\appendix
\chapter{Appendix}

\section{Language-Specific Caveats}\label{lang}

Here we will discuss some ``gotchas'' or signficant syntactic deviations from some popular programming languages that might catch the inexperienced reader off-guard if they try to apply the concepts above to that language. Once again, the goal is not to teach a specific language; this is just a collection of warnings and disclaimers that would otherwise have cluttered the main narrative.

\subsection{Scala / \texttt{cats}}\label{lang:scala}

\begin{itemize}
    \item typeclasses via implicits/traits
\end{itemize}

\subsection{Haskell}\label{lang:haskell}

\begin{itemize}
    \item type name translations (Maybe vs Optional, etc)
    \item data vs newtype
    \item newtype for re-implementing typeclasses
    \item dangers with laziness (e.g.\ foldr vs foldl)
    \item reader, writer, state defined in terms of their transformers
\end{itemize}

\subsection{TypeScript / \texttt{fp-ts}}\label{lang:fp-ts}

\begin{itemize}
    \item syntax difficulties
    \item type name translations (Option vs Optional, etc)
\end{itemize}

\subsection{Idris}\label{lang:idris}

\begin{itemize}
    \item labelled interfaces
\end{itemize}

\section{Right Folds From The Left}\label{endo}

Here we are going to look into how to implement a right fold generically, given only a left fold and no other information about the data structure. The idea is that we fold the structure up, from the left, \emph{into a function}, where the resulting function is designed to evaluate the right-most values first. Here's what that looks like:

\begin{lstlisting}[language=pseudoml]
foldr : Foldable t => (a -> b -> b) -> b -> t a -> b
foldr f z t = (foldl foo bar t) z where
    foo = _
    bar = _
\end{lstlisting}

This is pretty much a direct translation of the idea above: we left-fold (somehow) the structure \texttt{t} into a function that evaluates from the right, then kick it off with the given starting value. Now we just need to figure out what to use for \texttt{foo} and \texttt{bar}! Let's start by looking at their types, to see if they give us any clues. We know that \mlil{foldl foo bar t} must be a function, and it should have type \mlil{b -> b}. If we compare that to the type of \mlil{foldl},

\begin{lstlisting}[language=pseudoml]
foldl : Foldable t => (c -> a -> c) -> c -> t a -> c
\end{lstlisting}

\noindent in order to have the correct result type, we must have

\begin{lstlisting}[language=pseudoml]
foo : (b -> b) -> a -> (b -> b)
bar : (b -> b)
\end{lstlisting}

The second one is easy: whenever you need a value that fits that type signature, it almost certainly should be the identity function \mlil{id}. What about \texttt{foo}? Well let's treat it as a function of two arguments:

\begin{lstlisting}[language=pseudoml]
foo : (b -> b) -> a -> (b -> b)
foo g x = _
\end{lstlisting}

At this point, let's consider what gadgets we have available to us. We haven't yet used \mlil{f : a -> b -> b}, and now we also have \mlil{g : b -> b} and \mlil{x : a}. In general, unless you have a good reason, you want to try to use all of the variables you have handy. Interestingly, \mlil{f x} will have type \mlil{b -> b}, so what if we just compose that with \mlil{g}?

\begin{lstlisting}[language=pseudoml]
    foldr : Foldable t => (a -> b -> b) -> b -> t a -> b
    foldr f z t = (foldl foo id t) z where
        foo g x = g . f x
\end{lstlisting}

If you try this out, you'll find that this definition works exactly as we wanted it to! This is actually somewhat amazing, which is a pretty common occurrence with ``type-driven development'' as this method is usually called. We could have arrived at the same result if we sat down and worked out exactly what it means to ``left-fold a structure into a function that executes a right-fold'', but that would have required a lot more noodling.

To be honest, though, we cheated a little bit. Doing the composition in \texttt{foo} the other way around would have typechecked, but produces the wrong results:

\begin{lstlisting}[language=pseudoml]
    notFoldr : Foldable t => (a -> b -> b) -> b -> t a -> b
    notFoldr f z t = (foldl foo id t) z where
        foo g x = f x . g
\end{lstlisting}

If you work out an example, this turns out to look like a right fold\ldots{}but for a reversed input! This is the price of type-driven development: sometimes there is more than one choice to fill in a value for a given type, and the only way to determine which choice is correct is by testing it out yourself. Static type checking is not a substitute for \emph{all} tests!

\end{document}

